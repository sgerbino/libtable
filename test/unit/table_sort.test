
bool table_sort_test(char *buf, size_t len)
{
   table t;
   time_t now;
   int i, j, num_rows, num_cols, random_number, value_range = 20;
   bool rc = true;
   const size_t row_range = 100, col_range = 5;
   const size_t row_minimum = 100, col_minimum = 2;
   int error_row = -1;
   int error_column = -1;

   srand(time(&now));

   random_number = rand() % row_range + row_minimum;

   table_init(&t);

   for (i = 0; i < random_number; i++)
      table_add_row(&t);

   num_rows = table_get_row_length(&t);

   random_number = rand() % col_range + col_minimum;

   for (i = 0; i < random_number; i++)
   {
		char buf[255];
		snprintf(buf, sizeof(buf), "%d", i);
		table_add_column(&t, buf, TABLE_INT);
   }
   num_cols = table_get_column_length(&t);

   for (i = 0; i < num_cols; i++)
   {
	   for (j = 0; j < num_rows; j++)
	   {
		   int value = rand() % value_range;
		   table_set_int(&t, j, i, value);
	   }
   }

   int *cols = calloc(num_cols, sizeof(int));
   table_order *sort_orders = calloc(num_cols, sizeof(table_order));
   for (i = 0; i < num_cols; i++)
   {
	   cols[i] = i;
	   sort_orders[i] = rand()%2;
   }

   table_column_sort(&t, cols, sort_orders, num_cols);

   int *prev = calloc(num_cols, sizeof(int));
   for (i = 0; i < num_rows; i++)
   {
	   int *current = calloc(num_cols, sizeof(int));
	   for (j = 0; j < num_cols; j++)
		   current[j] = table_get_int(&t, i, j);

	   if (i > 0)
	   {
		   for (j = 0; j < num_cols; j++)
		   {
			   if (j == 0)
			   {
				   if (sort_orders[j] == TABLE_ASCENDING)
				   {
					   if (prev[j] > current[j])
					   {
						   snprintf(buf, len, "Row %d is not sorted correctly on column %d, sort order TABLE_ASCENDING", i, j);
						   error_row = i;
						   error_column = j;
						   rc = false;
					   }
				   }
				   else
				   {
					   if (prev[j] < current[j])
					   {
						   snprintf(buf, len, "Row %d is not sorted correctly on column %d, sort order TABLE_DESCENDING", i, j);
						   error_row = i;
						   error_column = j;
						   rc = false;
					   }
				   }
			   }
			   else
			   {
				   if (prev[j-1] == current[j-1])
				   {
					   if (sort_orders[j] == TABLE_ASCENDING)
					   {
						   if (prev[j] > current[j])
						   {
							   snprintf(buf, len, "Row %d is not sorted correctly on column %d, sort order TABLE_ASCENDING", i, j);
							   error_row = i;
                               error_column = j;
							   rc = false;
						   }
					   }
					   else
					   {
						   if (prev[j] < current[j])
						   {
							   snprintf(buf, len, "Row %d is not sorted correctly on column %d, sort order TABLE_DESCENDING", i, j);
							   error_row = i;
						       error_column = j;
							   rc = false;
						   }
					   }
				   }
			   }
		   }
	   }

	   for (j = 0; j < num_cols ; j++)
	   {
		   prev[j] = current[j];
	   }
	   free(current);
   }
   free(prev);

   if (error_row != -1)
   {
     int context = 10;
     char buf[255];
     int row, col;
     int row_len = table_get_row_length(&t);
     int row_context_min = error_row - context >= 0 ? error_row - context : 0;
     int row_context_max = error_row + context <= row_len ? error_row + context : row_len;

     puts("\n");
     for (row = row_context_min; row < row_context_max; row++)
     {
       for (col = 0; col < table_get_column_length(&t); col++)
       {
         table_cell_to_string(&t, row, col, buf, sizeof buf);
         if (error_row == row && error_column == col)
           printf("%s*\t", buf);
         else
           printf("%s\t", buf);
       }
       if (error_row == row)
         puts("!\n");
       else
         puts("\n");
     }
   }


   table_destroy(&t);

   return rc;
}
